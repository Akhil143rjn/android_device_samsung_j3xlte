diff --git a/headers/media_plugin/media/openmax/OMX_Audio.h b/headers/media_plugin/media/openmax/OMX_Audio.h
index 9c0296b..1e08b65 100644
--- a/headers/media_plugin/media/openmax/OMX_Audio.h
+++ b/headers/media_plugin/media/openmax/OMX_Audio.h
@@ -108,6 +108,7 @@ typedef enum OMX_AUDIO_CODINGTYPE {
     OMX_AUDIO_CodingFLAC,        /**< Any variant of FLAC encoded data */
     OMX_AUDIO_CodingKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
     OMX_AUDIO_CodingVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_AUDIO_CodingIMAADPCM,    /**< Any variant of IMAADPCM encoded data */
     OMX_AUDIO_CodingMax = 0x7FFFFFFF
 } OMX_AUDIO_CODINGTYPE;
 
@@ -470,6 +471,20 @@ typedef struct OMX_AUDIO_PARAM_ADPCMTYPE {
                                     variable or unknown sampling rate. */
 } OMX_AUDIO_PARAM_ADPCMTYPE;
 
+/** IMAADPCM stream format parameters */
+typedef struct OMX_AUDIO_PARAM_IMAADPCMTYPE {
+    OMX_U32 nSize;              /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
+    OMX_U32 nPortIndex;         /**< port that this structure applies to */
+    OMX_U32 nChannels;          /**< Number of channels in the data stream (not
+                                     necessarily the same as the number of channels
+                                     to be rendered. */
+    OMX_U32 nBitsPerSample;     /**< Number of bits in each sample */
+    OMX_U32 nSampleRate;        /**< Sampling rate of the source data.  Use 0 for
+                                    variable or unknown sampling rate. */
+    OMX_U32 nBlockAlign;        /**< Sampling rate of the source data.	Use 0 for
+                                    variable or unknown sampling rate. */
+} OMX_AUDIO_PARAM_IMAADPCMTYPE;
 
 /** G723 rate */
 typedef enum OMX_AUDIO_G723RATE {
diff --git a/headers/media_plugin/media/openmax/OMX_IVCommon.h b/headers/media_plugin/media/openmax/OMX_IVCommon.h
index f9b6f4b..4934a2e 100644
--- a/headers/media_plugin/media/openmax/OMX_IVCommon.h
+++ b/headers/media_plugin/media/openmax/OMX_IVCommon.h
@@ -170,6 +170,7 @@ typedef enum OMX_COLOR_FORMATTYPE {
     OMX_QCOM_COLOR_FormatYUV420PackedSemiPlanar64x32Tile2m8ka = 0x7FA30C03,
     OMX_SEC_COLOR_FormatNV12Tiled = 0x7FC00002,
     OMX_QCOM_COLOR_FormatYUV420PackedSemiPlanar32m = 0x7FA30C04,
+    OMX_SPRD_COLOR_FormatYVU420SemiPlanar = 0x7FD00001,
     OMX_COLOR_FormatMax = 0x7FFFFFFF
 } OMX_COLOR_FORMATTYPE;
 
diff --git a/headers/media_plugin/media/openmax/OMX_Index.h b/headers/media_plugin/media/openmax/OMX_Index.h
index 5be1355..cf7fbd0 100644
--- a/headers/media_plugin/media/openmax/OMX_Index.h
+++ b/headers/media_plugin/media/openmax/OMX_Index.h
@@ -198,6 +198,7 @@ typedef enum OMX_INDEXTYPE {
     OMX_IndexParamVideoSliceFMO,            /**< reference: OMX_VIDEO_PARAM_AVCSLICEFMO */
     OMX_IndexConfigVideoAVCIntraPeriod,     /**< reference: OMX_VIDEO_CONFIG_AVCINTRAPERIOD */
     OMX_IndexConfigVideoNalSize,            /**< reference: OMX_VIDEO_CONFIG_NALSIZE */
+    OMX_IndexConfigEncSceneMode,
     OMX_IndexVideoEndUnused,
 
     /* Image & Video common Configurations */
@@ -268,6 +269,7 @@ typedef enum OMX_INDEXTYPE {
        private indexes are not guaranteed unique and therefore should
        only be sent to the appropriate component. */
 
+    OMX_IndexParamAudioImaAdpcm = 0x7FA7B09C,/**< reference: OMX_AUDIO_PARAM_IMAADPCMTYPE */
     OMX_IndexMax = 0x7FFFFFFF
 
 } OMX_INDEXTYPE;
diff --git a/headers/media_plugin/media/openmax/OMX_Video.h b/headers/media_plugin/media/openmax/OMX_Video.h
index 76efac9..479c20b 100644
--- a/headers/media_plugin/media/openmax/OMX_Video.h
+++ b/headers/media_plugin/media/openmax/OMX_Video.h
@@ -961,6 +961,23 @@ typedef struct OMX_VIDEO_CONFIG_BITRATETYPE {
 } OMX_VIDEO_CONFIG_BITRATETYPE;
 
 /**
+ * Defines Encoder Scene Mode setting
+ *
+ * STRUCT MEMBERS:
+ *  nSize            : Size of the structure in bytes
+ *  nVersion         : OMX specification version information
+ *  nPortIndex       : Port that this structure applies to
+ *  nMode : Encoding scene mode(1:Volte, 2:Wfd, 0:Normal)
+ */
+
+typedef struct OMX_VIDEO_CONFIG_ENCODERSCENEMODE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nMode;
+} OMX_VIDEO_CONFIG_ENCODERSCENEMODE;
+
+/**
  * Defines Encoder Frame Rate setting
  *
  * STRUCT MEMBERS:
diff --git a/libs/binder/IPCThreadState.cpp b/libs/binder/IPCThreadState.cpp
index e832961..a92c74f 100644
--- a/libs/binder/IPCThreadState.cpp
+++ b/libs/binder/IPCThreadState.cpp
@@ -1138,6 +1138,12 @@ status_t IPCThreadState::executeCommand(int32_t cmd)
         mProcess->spawnPooledThread(false);
         break;
 
+    // SPRD: Sometimes, doing binder operation in destructor could reveiving BR_TRANSACTION_COMPLETE here.
+    //       We handle this command simply and avoid crash.
+    case BR_TRANSACTION_COMPLETE:
+        ALOGE("*** BAD COMMAND: BR_TRANSACTION_COMPLETE(%x) for executeCommand from Binder driver\n", cmd);
+        break;
+
     default:
         ALOGE("*** BAD COMMAND %d received from Binder driver\n", cmd);
         result = UNKNOWN_ERROR;
diff --git a/services/surfaceflinger/Android.mk b/services/surfaceflinger/Android.mk
index fab3795..e1f1983 100644
--- a/services/surfaceflinger/Android.mk
+++ b/services/surfaceflinger/Android.mk
@@ -49,6 +49,10 @@ LOCAL_C_INCLUDES := \
 LOCAL_CFLAGS := -DLOG_TAG=\"SurfaceFlinger\"
 LOCAL_CFLAGS += -DGL_GLEXT_PROTOTYPES -DEGL_EGLEXT_PROTOTYPES
 
+ifeq ($(strip $(TARGET_GPU_NOT_SUPPORT_NV12_OUTPUT)),true)
+    LOCAL_CFLAGS += -DGPU_NOT_SUPPORT_NV12_OUTPUT
+endif
+
 ifeq ($(TARGET_USES_HWC2),true)
     LOCAL_CFLAGS += -DUSE_HWC2
     LOCAL_SRC_FILES += \
diff --git a/services/surfaceflinger/DisplayDevice.cpp b/services/surfaceflinger/DisplayDevice.cpp
index a4b1412..0c54ab0 100644
--- a/services/surfaceflinger/DisplayDevice.cpp
+++ b/services/surfaceflinger/DisplayDevice.cpp
@@ -141,7 +141,33 @@ DisplayDevice::DisplayDevice(
                                                /*logConfig*/ false);
 #endif
     }
-    eglSurface = eglCreateWindowSurface(display, config, window, NULL);
+    
+    /*
+     *  Sprd change here:
+     *  Enable EGL NV12 config for GPU output NV12 image, for
+     *  VirtualDisplay.
+     * */
+#ifndef GPU_NOT_SUPPORT_NV12_OUTPUT
+    if (mType >= DisplayDevice::DISPLAY_VIRTUAL)
+    {
+        EGLConfig nv12Config;
+        EGLint numConfigs = 0;
+        static EGLint sDefaultConfigAttribs[] = {
+            EGL_CONFIG_ID, 43, EGL_NONE };
+        eglChooseConfig(display, sDefaultConfigAttribs, &nv12Config, 1, &numConfigs);
+        eglSurface = eglCreateWindowSurface(display, nv12Config, window, NULL);
+
+        /*
+         * Sync Framebuffer format to VirtualDisplay Surface.
+         * */
+        format = mDisplaySurface->getFBFormat();
+        native_window_set_buffers_format(window, format);
+    }
+    else
+#endif
+    {
+        eglSurface = eglCreateWindowSurface(display, config, window, NULL);
+    }
     eglQuerySurface(display, eglSurface, EGL_WIDTH,  &mDisplayWidth);
     eglQuerySurface(display, eglSurface, EGL_HEIGHT, &mDisplayHeight);
 
@@ -188,7 +214,7 @@ DisplayDevice::DisplayDevice(
     mHardwareRotation = property_get_int32("ro.sf.hwrotation", 0) / 90;
 
     // initialize the display orientation transform.
-    setProjection(DisplayState::eOrientationDefault, mViewport, mFrame);
+    setDisplayDevice();
 
     if (useTripleFramebuffer) {
         surface->allocateBuffers();
@@ -386,11 +412,65 @@ EGLBoolean DisplayDevice::makeCurrent(EGLDisplay dpy, EGLContext ctx) const {
 void DisplayDevice::setViewportAndProjection() const {
     size_t w = mDisplayWidth;
     size_t h = mDisplayHeight;
+    char property[PROPERTY_VALUE_MAX];
+    if ((mType == DisplayDevice::DISPLAY_PRIMARY)
+        && (property_get("ro.sf.hwrotation", property, NULL) > 0)) {
+        //displayOrientation
+        switch (atoi(property)) {
+            case 90:
+            case 270:
+            w = mDisplayHeight;
+            h = mDisplayWidth;
+            break;
+            default:
+            break;
+        }
+    }
     Rect sourceCrop(0, 0, w, h);
     mFlinger->getRenderEngine().setViewportAndProjection(w, h, sourceCrop, h,
         false, Transform::ROT_0);
 }
 
+void DisplayDevice::setDisplayDevice()
+{
+	// initialize the display orientation transform.
+	// it's a constant that should come from the display driver.
+	int displayOrientation = DisplayState::eOrientationDefault;
+	char property[PROPERTY_VALUE_MAX];
+	if ((mType == DisplayDevice::DISPLAY_PRIMARY)
+           && (property_get("ro.sf.hwrotation", property, NULL) > 0)) {
+		//displayOrientation
+		switch (atoi(property)) {
+			case 90:
+			displayOrientation = DisplayState::eOrientation90;
+			break;
+
+			case 180:
+			displayOrientation = DisplayState::eOrientation180;
+			break;
+
+			case 270:
+			displayOrientation = DisplayState::eOrientation270;
+			break;
+		}
+	}
+
+	const int w = mDisplayWidth;
+	const int h = mDisplayHeight;
+	DisplayDevice::orientationToTransfrom(displayOrientation, w, h,
+	&mDisplayTransform);
+	if (displayOrientation & DisplayState::eOrientationSwapMask) {
+		mDisplayWidth = h;
+		mDisplayHeight = w;
+	} else {
+		mDisplayWidth = w;
+		mDisplayHeight = h;
+	}
+
+	// initialize the display orientation transform.
+	setProjection(DisplayState::eOrientationDefault, mViewport, mFrame);
+}
+
 const sp<Fence>& DisplayDevice::getClientTargetAcquireFence() const {
     return mDisplaySurface->getClientTargetAcquireFence();
 }
@@ -593,7 +673,8 @@ void DisplayDevice::setProjection(int orientation,
     // The viewport and frame are both in the logical orientation.
     // Apply the logical translation, scale to physical size, apply the
     // physical translation and finally rotate to the physical orientation.
-    mGlobalTransform = R * TP * S * TL;
+    mGlobalTransform = mDisplayTransform * R * TP * S * TL;
+    mOriginalTransform = R * TP * S * TL;
 
     const uint8_t type = mGlobalTransform.getType();
     mNeedsFiltering = (!mGlobalTransform.preserveRects() ||
diff --git a/services/surfaceflinger/DisplayDevice.h b/services/surfaceflinger/DisplayDevice.h
index c054feb..a30ac1c 100644
--- a/services/surfaceflinger/DisplayDevice.h
+++ b/services/surfaceflinger/DisplayDevice.h
@@ -134,6 +134,7 @@ public:
     uint32_t                getOrientationTransform() const;
     static uint32_t         getPrimaryDisplayOrientationTransform();
     const Transform&        getTransform() const { return mGlobalTransform; }
+    const Transform&        getOriginalTransform() const { return mOriginalTransform; }
     const Rect              getViewport() const { return mViewport; }
     const Rect              getFrame() const { return mFrame; }
     const Rect&             getScissor() const { return mScissor; }
@@ -248,6 +249,8 @@ private:
     status_t orientationToTransfrom(int orientation,
             int w, int h, Transform* tr);
 
+    void setDisplayDevice();
+
     // The identifier of the active layer stack for this display. Several displays
     // can use the same layer stack: A z-ordered group of layers (sometimes called
     // "surfaces"). Any given layer can only be on a single layer stack.
@@ -262,6 +265,8 @@ private:
     // pre-computed scissor to apply to the display
     Rect mScissor;
     Transform mGlobalTransform;
+    Transform mOriginalTransform;
+    Transform mDisplayTransform;
     bool mNeedsFiltering;
     // Current power mode
     int mPowerMode;
diff --git a/services/surfaceflinger/DisplayHardware/DisplaySurface.h b/services/surfaceflinger/DisplayHardware/DisplaySurface.h
index cb08f08..4109f42 100644
--- a/services/surfaceflinger/DisplayHardware/DisplaySurface.h
+++ b/services/surfaceflinger/DisplayHardware/DisplaySurface.h
@@ -21,6 +21,8 @@
 #include <utils/RefBase.h>
 #include <utils/StrongPointer.h>
 
+#include <system/graphics-base.h>
+
 // ---------------------------------------------------------------------------
 namespace android {
 // ---------------------------------------------------------------------------
@@ -79,8 +81,16 @@ public:
 
     virtual const sp<Fence>& getClientTargetAcquireFence() const = 0;
 
+    inline int getFBFormat() const
+    {
+        return mFBFormat;
+    }
+
 protected:
-    DisplaySurface() {}
+    int mFBFormat;
+    DisplaySurface()
+    : mFBFormat(HAL_PIXEL_FORMAT_RGBA_8888)
+    {}
     virtual ~DisplaySurface() {}
 };
 
diff --git a/services/surfaceflinger/DisplayHardware/VirtualDisplaySurface.cpp b/services/surfaceflinger/DisplayHardware/VirtualDisplaySurface.cpp
index 1de5e48..b6037bd 100644
--- a/services/surfaceflinger/DisplayHardware/VirtualDisplaySurface.cpp
+++ b/services/surfaceflinger/DisplayHardware/VirtualDisplaySurface.cpp
@@ -91,6 +91,7 @@ VirtualDisplaySurface::VirtualDisplaySurface(HWComposer& hwc, int32_t dispId,
     // with GLES. If the consumer needs CPU access, use the default format
     // set by the consumer. Otherwise allow gralloc to decide the format based
     // on usage bits.
+#if 0
     int sinkUsage;
     sink->query(NATIVE_WINDOW_CONSUMER_USAGE_BITS, &sinkUsage);
     if (sinkUsage & (GRALLOC_USAGE_SW_READ_MASK | GRALLOC_USAGE_SW_WRITE_MASK)) {
@@ -100,7 +101,13 @@ VirtualDisplaySurface::VirtualDisplaySurface(HWComposer& hwc, int32_t dispId,
     } else {
         mDefaultOutputFormat = HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED;
     }
+#else
+    int sinkFormat;
+    sink->query(NATIVE_WINDOW_FORMAT, &sinkFormat);
+    mDefaultOutputFormat = sinkFormat;
+#endif
     mOutputFormat = mDefaultOutputFormat;
+    mFBFormat = mDefaultOutputFormat;
 
     ConsumerBase::mName = String8::format("VDS: %s", mDisplayName.string());
     mConsumer->setConsumerName(ConsumerBase::mName);
diff --git a/services/surfaceflinger/Layer.cpp b/services/surfaceflinger/Layer.cpp
index 038ece2..f7c8fc7 100755
--- a/services/surfaceflinger/Layer.cpp
+++ b/services/surfaceflinger/Layer.cpp
@@ -960,7 +960,7 @@ void Layer::setPerFrameData(const sp<const DisplayDevice>& hw,
     // after HWComposer::commit() -- every frame.
     // Apply this display's projection's viewport to the visible region
     // before giving it to the HWC HAL.
-    const Transform& tr = hw->getTransform();
+    const Transform& tr = hw->getOriginalTransform();
     Region visible = tr.transform(visibleRegion.intersect(hw->getViewport()));
     layer.setVisibleRegionScreen(visible);
     layer.setSurfaceDamage(surfaceDamageRegion);
@@ -1439,7 +1439,21 @@ void Layer::computeGeometry(const sp<const DisplayDevice>& hw, Mesh& mesh,
 {
     const Layer::State& s(getDrawingState());
     const Transform hwTransform(hw->getTransform());
-    const uint32_t hw_h = hw->getHeight();
+    uint32_t hw_h = hw->getHeight();
+    char property[PROPERTY_VALUE_MAX];
+    if ((hw->getDisplayType() == DisplayDevice::DISPLAY_PRIMARY)
+        && (property_get("ro.sf.hwrotation", property, NULL) > 0)) {
+        //displayOrientation
+        switch (atoi(property)) {
+            case 90:
+            case 270:
+                hw_h = hw->getWidth();
+                break;
+            default:
+                break;
+        }
+    }
+
     Rect win = computeBounds();
 
     vec2 lt = vec2(win.left, win.top);
diff --git a/services/surfaceflinger/SurfaceFlinger.cpp b/services/surfaceflinger/SurfaceFlinger.cpp
index 63f94c6..91fa5e8 100644
--- a/services/surfaceflinger/SurfaceFlinger.cpp
+++ b/services/surfaceflinger/SurfaceFlinger.cpp
@@ -822,6 +822,20 @@ status_t SurfaceFlinger::getDisplayConfigs(const sp<IBinder>& display,
         } else {
             info.w = hwConfig->getWidth();
             info.h = hwConfig->getHeight();
+            char property[PROPERTY_VALUE_MAX];
+            if ((type == DisplayDevice::DISPLAY_PRIMARY)
+                && (property_get("ro.sf.hwrotation", property, NULL) > 0)) {
+                //displayOrientation
+                switch (atoi(property)) {
+                    case 90:
+                    case 270:
+                    info.w = hwConfig.height;
+                    info.h = hwConfig.width;
+                    break;
+                    default:
+                    break;
+                }
+            }
             info.xdpi = xdpi;
             info.ydpi = ydpi;
         }
@@ -1757,7 +1771,7 @@ void SurfaceFlinger::rebuildLayerStacks() {
             Region dirtyRegion;
             Vector<sp<Layer>> layersSortedByZ;
             const sp<DisplayDevice>& displayDevice(mDisplays[dpy]);
-            const Transform& tr(displayDevice->getTransform());
+            const Transform& tr(displayDevice->getOriginalTransform());
             const Rect bounds(displayDevice->getBounds());
             if (displayDevice->isDisplayOn()) {
                 computeVisibleRegions(displayDevice, dirtyRegion, opaqueRegion);
@@ -2722,7 +2736,7 @@ bool SurfaceFlinger::doComposeSurfaces(
      */
 
     ALOGV("Rendering client layers");
-    const Transform& displayTransform = displayDevice->getTransform();
+    const Transform& displayTransform = displayDevice->getOriginalTransform();
     if (hwcId >= 0) {
         // we're using h/w composer
         bool firstLayer = true;
